import firebase_admin
from firebase_admin import credentials, firestore
# REMOVED: from tkinter import messagebox # No longer directly using messagebox here
import bcrypt # For hashing user passwords and PINs
import os # For generating salt
import base64 # For encoding salt

# --- Database Schema Assumption (Firestore - Production Focus) ---
# Collection: 'users'
#   Document ID: (auto-generated by Firestore)
#   Fields:
#     name: STRING
#     email: STRING (indexed for queries)
#     password: STRING (BCRYPT HASH of user's login password)
#     recovery_email: STRING (indexed for queries)
#     pin: STRING (BCRYPT HASH of user's PIN, if set, or null)
#     key_salt: STRING (Base64 encoded random salt for deriving data encryption key)
#     created_at: TIMESTAMP
#
# Collection: 'passwords'
#   Document ID: (auto-generated by Firestore)
#   Fields:
#     user_id: STRING (references document ID in 'users' collection, indexed)
#     app: STRING
#     username: STRING
#     password: STRING (ENCRYPTED with Fernet using key derived from user's master password + key_salt)
#     email: STRING
#     created_at: TIMESTAMP
#     updated_at: TIMESTAMP
# --- End Database Schema Assumption ---

def hash_value(plain_value: str) -> str:
    """Hashes a plain text value using bcrypt."""
    if not plain_value:
        return None
    salt = bcrypt.gensalt()
    hashed_bytes = bcrypt.hashpw(plain_value.encode('utf-8'), salt)
    return hashed_bytes.decode('utf-8')

def check_hashed_value(plain_value: str, hashed_value_str: str) -> bool:
    """Checks a plain text value against a stored bcrypt hash."""
    if not plain_value or not hashed_value_str:
        return False
    return bcrypt.checkpw(plain_value.encode('utf-8'), hashed_value_str.encode('utf-8'))

class FirebaseService:
    def __init__(self, credentials_path="Password-Manager/serviceAccountKey.json"):
        self.db = None
        self.users_collection_ref = None
        self.passwords_collection_ref = None
        try:
            cred = credentials.Certificate(credentials_path)
            if not firebase_admin._apps:
                 firebase_admin.initialize_app(cred)
            else:
                 firebase_admin.get_app()
            self.db = firestore.client()
            self.users_collection_ref = self.db.collection('users')
            self.passwords_collection_ref = self.db.collection('passwords')
            print("Successfully connected to Firebase Firestore.")
        except Exception as e:
            # Log the error. The UI will check self.db and inform the user.
            error_message = f"Error initializing Firebase in FirebaseService: {e}\n" \
                            f"Please ensure '{credentials_path}' is valid and accessible."
            print(error_message)
            # self.db will remain None, which ui.py will check.

    def get_user_by_email(self, email):
        if not self.users_collection_ref: return None
        try:
            users_query = self.users_collection_ref.where('email', '==', email).limit(1).stream()
            for user_doc in users_query:
                user_data = user_doc.to_dict()
                user_data['id'] = user_doc.id
                return user_data
            return None
        except Exception as e:
            print(f"Error getting user by email '{email}': {e}")
            return None

    def get_user_by_id(self, user_id):
        if not self.users_collection_ref: return None
        try:
            doc_ref = self.users_collection_ref.document(user_id)
            doc = doc_ref.get()
            if doc.exists:
                user_data = doc.to_dict()
                user_data['id'] = doc.id
                return user_data
            return None
        except Exception as e:
            print(f"Error getting user by ID '{user_id}': {e}")
            return None

    def get_user_by_email_or_recovery(self, email_or_recovery):
        if not self.users_collection_ref: return None
        user_by_email = self.get_user_by_email(email_or_recovery)
        if user_by_email:
            return user_by_email
        try:
            users_query_recovery = self.users_collection_ref.where('recovery_email', '==', email_or_recovery).limit(1).stream()
            for user_doc in users_query_recovery:
                user_data = user_doc.to_dict()
                user_data['id'] = user_doc.id
                return user_data
            return None
        except Exception as e:
            print(f"Error in get_user_by_email_or_recovery for '{email_or_recovery}': {e}")
            return None

    def create_user(self, name, email, plain_password, recovery_email, plain_pin=None):
        if not self.users_collection_ref: return None
        try:
            if self.get_user_by_email(email):
                return "exists"

            hashed_password = hash_value(plain_password)
            hashed_pin = hash_value(plain_pin) if plain_pin else None
            key_salt_bytes = os.urandom(16)
            key_salt_b64 = base64.urlsafe_b64encode(key_salt_bytes).decode('utf-8')

            user_data = {
                'name': name,
                'email': email,
                'password': hashed_password,
                'recovery_email': recovery_email,
                'pin': hashed_pin,
                'key_salt': key_salt_b64,
                'created_at': firestore.SERVER_TIMESTAMP
            }
            _timestamp, doc_ref = self.users_collection_ref.add(user_data)
            return doc_ref.id
        except Exception as e:
            print(f"Error creating user '{email}': {e}")
            return None

    def update_user(self, user_id, data_to_update):
        if not self.users_collection_ref: return False
        try:
            if 'password' in data_to_update and data_to_update['password'] is not None:
                data_to_update['password'] = hash_value(data_to_update['password'])
            elif 'password' in data_to_update and data_to_update['password'] is None:
                del data_to_update['password']

            if 'pin' in data_to_update and data_to_update['pin'] is not None:
                data_to_update['pin'] = hash_value(data_to_update['pin'])
            elif 'pin' in data_to_update and data_to_update['pin'] is None:
                 data_to_update['pin'] = None

            self.users_collection_ref.document(user_id).update(data_to_update)
            return True
        except Exception as e:
            print(f"Error updating user '{user_id}': {e}")
            return False

    def get_passwords_for_user(self, user_id, encryption_service, search_term=None):
        if not self.passwords_collection_ref or not encryption_service: return []
        try:
            query = self.passwords_collection_ref.where('user_id', '==', user_id)
            all_passwords_for_user = []
            for doc in query.order_by('app').stream():
                entry = doc.to_dict()
                entry['id'] = doc.id
                try:
                    decrypted_password = encryption_service.decrypt(entry.get('password', ''))
                    entry['password'] = decrypted_password
                except Exception as decrypt_error:
                    print(f"Error decrypting password for entry {entry['id']}: {decrypt_error}")
                    entry['password'] = "DECRYPTION_ERROR"
                all_passwords_for_user.append(entry)

            if not search_term:
                return all_passwords_for_user

            st_lower = search_term.lower()
            filtered_results = [
                entry for entry in all_passwords_for_user if
                st_lower in entry.get('app', '').lower() or
                st_lower in entry.get('username', '').lower() or
                st_lower in entry.get('email', '').lower()
            ]
            filtered_results.sort(key=lambda x: (x.get('app', '').lower(), x.get('username', '').lower()))
            return filtered_results
        except Exception as e:
            print(f"Error fetching passwords for user '{user_id}': {e}")
            return []

    def add_password_entry(self, user_id, app, username, plain_password_value, email_value, encryption_service):
        if not self.passwords_collection_ref or not encryption_service: return None
        try:
            encrypted_password = encryption_service.encrypt(plain_password_value)
            entry_data = {
                'user_id': user_id,
                'app': app,
                'username': username,
                'password': encrypted_password,
                'email': email_value,
                'created_at': firestore.SERVER_TIMESTAMP,
                'updated_at': firestore.SERVER_TIMESTAMP
            }
            _timestamp, doc_ref = self.passwords_collection_ref.add(entry_data)
            return doc_ref.id
        except Exception as e:
            print(f"Error adding password entry for app '{app}': {e}")
            return None

    def get_password_entry_by_id(self, password_id, user_id_check, encryption_service):
        if not self.passwords_collection_ref or not encryption_service: return None
        try:
            doc_ref = self.passwords_collection_ref.document(password_id)
            doc = doc_ref.get()
            if doc.exists:
                data = doc.to_dict()
                if data.get('user_id') == user_id_check:
                    data['id'] = doc.id
                    try:
                        decrypted_password = encryption_service.decrypt(data.get('password', ''))
                        data['password'] = decrypted_password
                    except Exception as decrypt_error:
                        print(f"Error decrypting password for entry {data['id']} on get: {decrypt_error}")
                        data['password'] = "DECRYPTION_ERROR"
                    return data
            return None
        except Exception as e:
            print(f"Error getting password entry '{password_id}': {e}")
            return None

    def update_password_entry(self, password_id, user_id_check, data_to_update, encryption_service):
        if not self.passwords_collection_ref or not encryption_service: return False
        try:
            doc_ref = self.passwords_collection_ref.document(password_id)
            doc_snapshot = doc_ref.get()
            if not doc_snapshot.exists or doc_snapshot.to_dict().get('user_id') != user_id_check:
                print(f"Update failed: Password entry {password_id} not found or user mismatch.")
                return False

            if 'password' in data_to_update and data_to_update['password'] is not None:
                data_to_update['password'] = encryption_service.encrypt(data_to_update['password'])

            data_to_update['updated_at'] = firestore.SERVER_TIMESTAMP
            doc_ref.update(data_to_update)
            return True
        except Exception as e:
            print(f"Error updating password entry '{password_id}': {e}")
            return False

    def delete_password_entry(self, password_id, user_id_check):
        if not self.passwords_collection_ref: return False
        try:
            doc_ref = self.passwords_collection_ref.document(password_id)
            doc_snapshot = doc_ref.get()
            if not doc_snapshot.exists or doc_snapshot.to_dict().get('user_id') != user_id_check:
                print(f"Delete failed: Password entry {password_id} not found or user mismatch.")
                return False
            doc_ref.delete()
            return True
        except Exception as e:
            print(f"Error deleting password entry '{password_id}': {e}")
            return False